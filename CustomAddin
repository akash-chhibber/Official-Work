Sub uppercase()
    Dim number As Integer
    Dim sh As Worksheet
        On Error Resume Next
    
    number = InputBox("where do you want to run this macro, Enter 1 for selection across sheets, 2 for whole sheet and 3 for entire workbook:")
    result = number
    Select Case result
    Case Is = 1
        MsgBox ("you have chosen to run on selection.")
        For Each sh In Worksheets
            sh.Activate
            Set rng = Selection ' sh.UsedRange.SpecialCells(xlCellTypeConstants) 'Application.ActiveSheet.UsedRange
'    If Err.Number <> 0 Then
'        Err.Clear
'    Else
'    On Error GoTo 0
            For Each Cell In rng
                If (Cell.Value <> "") Then
                    Cell.Value = UCase(Left(Cell.Value, 1)) & Right(Cell.Value, Len(Cell.Value) - 1)
                End If
            Next
            MsgBox "Now running on sheet :" & sh.Name
        Next
'    End If
        MsgBox "done!"
        
    Case Is = 2
        MsgBox ("You have chosen to run on entire sheet.")
        
        For Each Cell In Application.ActiveSheet.UsedRange
            If (Cell.Value <> "") Then
                Cell.Value = UCase(Left(Cell.Value, 1)) & Right(Cell.Value, Len(Cell.Value) - 1)
            End If
        Next
        MsgBox "done!"
    Case Is = 3
        MsgBox ("You have chosen to run on entire workbook.")
        For Each sh In ActiveWorkbook.Worksheets
        sh.Activate
        For Each Cell In Application.ActiveSheet.UsedRange
            If (Cell.Value <> "") Then
                Cell.Value = UCase(Left(Cell.Value, 1)) & Right(Cell.Value, Len(Cell.Value) - 1)
            End If
        Next
        Next
        MsgBox "done!"
    
    End Select
     
End Sub

Sub Clean_and_Trim_Cells()
    Application.ScreenUpdating = False
    Application.Calculation = xlCalculationManual
    Dim s As String
    For Each c In ActiveSheet.UsedRange
        s = c.Value
        If Trim(Application.Clean(s)) <> s Then
            s = Trim(Application.Clean(s))
            c.Value = s
        End If
    Next
    Application.ScreenUpdating = True
    Application.Calculation = xlCalculationAutomatic
End Sub



Sub ResetComments()
'Update 20141110
Dim pComment As Comment
For Each pComment In Application.ActiveSheet.Comments
   pComment.Shape.Top = pComment.Parent.Top + 5
   pComment.Shape.Left = pComment.Parent.Offset(0, 1).Left + 5
Next
End Sub


Sub MakeAllTablesRegularRanges()
  Dim WS As Worksheet, LO As ListObject
  For Each WS In Worksheets
    For Each LO In WS.ListObjects
      LO.Unlist
    Next
  Next
End Sub


Sub UnhideAllSheets()

'Unhide all sheets in workbook.

Dim WS As Worksheet

For Each WS In ActiveWorkbook.Worksheets

WS.Visible = xlSheetVisible

Next WS

End Sub


Sub Boombox()
Dim WS As Worksheet
 Application.ScreenUpdating = False
For Each WS In Worksheets
  WS.Activate
ActiveWindow.DisplayGridlines = False
    ActiveWindow.Zoom = 90
    ActiveWindow.View = xlNormalView
    ActiveSheet.DisplayPageBreaks = False
    Range("A1").Select
  Cells.Select
  'Cells.EntireColumn.AutoFit
'    With Selection
'        .VerticalAlignment = xlTop
'    End With
    Range("A1").Select
Next
 Application.ScreenUpdating = True
End Sub



Sub Propercase()

For Each Cell In Application.ActiveSheet.UsedRange
    If (Cell.Value <> "") Then
         Cell.Value = WorksheetFunction.Proper(Cell.Value)
    End If
Next
MsgBox "done!"
End Sub


 
Sub Correcting()
  Dim s As String
  Dim r As Range, c As Range
  Dim re As Object, mc As Object, m As Object
  Dim i As Long
Dim sht As Worksheet
Dim LastRow As Long
Set sht = ActiveSheet
    'Range("F2").Select
'    'ActiveCell.FormulaR1C1 = "=RC[-1]&""!<B>Original Text:!</B>""&RC[-2]" '&""</B>"""
'    Range("D2").Select
'    Selection.End(xlDown).Activate
'    Selection = ActiveCell.Offset(0, 1).Select
'MsgBox sht.UsedRange.Rows.Count
      LastRow = sht.UsedRange.Rows(sht.UsedRange.Rows.Count).Row
'    ActiveCell.FormulaR1C1 = " "
'    Range("D2").Select
'    With ThisWorkbook.Sheets("Sheet1")
'       .Range("D2:D" & LastRow).FillDown
'    End With
'    Range("D2:D" & LastRow).Select
'Selection.Copy
'Selection.PasteSpecial xlPasteValues
 
FindReplaceAll
Range("F2:F" & LastRow).Select
MakeSubTextBold
 Boombox
End Sub
Function MakeSubTextBold()
  Dim x As Long, Position As Long, Cell As Range
  Dim msg As String, Txt As String, Parts() As String
  For Each Cell In Selection
    Position = 0
    Txt = Cell.Value
    If InStr(Txt, "</B>") Then
      If UBound(Split(Txt, "<B>")) = UBound(Split(Txt, "</B>")) Then
        Txt = Replace(Txt, "</B>", "<B>")
        Parts = Split(Txt, "<B>")
        Cell.Font.Bold = False
        Cell.Value = Join(Parts, "")
        For x = 1 To UBound(Parts) Step 2
          Position = Position + Len(Parts(x - 1))
          Cell.Characters(Position, Len(Parts(x))).Font.Bold = True
          Position = Position + Len(Parts(x))
        Next
      Else
        msg = msg & Cell.Address(0, 0) & vbLf
      End If
    End If
  Next
  If Len(msg) Then MsgBox "These cells had unbalanced tags and were not processed:" & _
              vbLf & "======================================" & vbLf & msg, vbCritical
End Function
 
 
Function \()
Dim sht As Worksheet
Dim fnd As Variant
Dim rplc As Variant
 
fnd = "!"
rplc = Chr(10)
 
For Each sht In ActiveWorkbook.Worksheets
  sht.Cells.Replace what:=fnd, Replacement:=rplc, _
    LookAt:=xlPart, SearchOrder:=xlByRows, MatchCase:=False, _
    SearchFormat:=False, ReplaceFormat:=False
Next sht
 
End Function

Sub BoldTextString()
  Dim s As String
  Dim r As Range, c As Range
  Dim re As Object, mc As Object, m As Object
  Dim i As Long
 
Set r = Selection
Set re = CreateObject("vbscript.regexp")
    re.Global = True
    re.ignorecase = True
  
For Each c In r
    re.Pattern = "<B>[\s\S]+?</B>"
        Set mc = re.Execute(c.Text)
    re.Pattern = "</?B>"
   c.Value = re.Replace(c.Text, "")
    i = 0
    For Each m In mc
        c.Characters(m.firstindex + 1 - 7 * i, _
            m.Length - 3).Font.Bold = True
        i = i + 1
    Next m
Next c
End Sub
 
Sub Macro2()
Dim sht As Worksheet
Dim LastRow As Long
Set sht = ThisWorkbook.Worksheets("Sheet1")
    Range("F2").Select
    ActiveCell.FormulaR1C1 = "=RC[-1]&""!<b>Original Text!</b>""&RC[-2]"
    Range("E2").Select
    Selection.End(xlDown).Activate
    Selection = ActiveCell.Offset(0, 1).Select
    LastRow = sht.UsedRange.Rows(sht.UsedRange.Rows.Count).Row
    ActiveCell.FormulaR1C1 = " "
    Range("F2").Select
    With ThisWorkbook.Sheets("Sheet1")
        .Range("F2:F" & LastRow).FillDown
    End With
End Sub

 
 
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' ExportToTextFile
' This exports a sheet or range to a text file, using a
' user-defined separator character.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Public Sub ExportToTextFile(FName As String, _
Sep As String, SelectionOnly As Boolean, _
AppendData As Boolean)

Dim WholeLine As String
Dim FNum As Integer
Dim RowNdx As Long
Dim ColNdx As Integer
Dim StartRow As Long
Dim EndRow As Long
Dim StartCol As Integer
Dim EndCol As Integer
Dim CellValue As String


Application.ScreenUpdating = False
On Error GoTo EndMacro:
FNum = FreeFile

If SelectionOnly = True Then
With Selection
StartRow = .Cells(1).Row
StartCol = .Cells(1).Column
EndRow = .Cells(.Cells.Count).Row
EndCol = .Cells(.Cells.Count).Column
End With
Else
With ActiveSheet.UsedRange
StartRow = .Cells(1).Row
StartCol = .Cells(1).Column
EndRow = .Cells(.Cells.Count).Row
EndCol = .Cells(.Cells.Count).Column
End With
End If

If AppendData = True Then
Open FName For Append Access Write As #FNum
Else
Open FName For Output Access Write As #FNum
End If

For RowNdx = StartRow To EndRow
WholeLine = ""
For ColNdx = StartCol To EndCol
If Cells(RowNdx, ColNdx).Value = "" Then
CellValue = Chr(34) & Chr(34)
Else
CellValue = Cells(RowNdx, ColNdx).Value
End If
WholeLine = WholeLine & CellValue & Sep
Next ColNdx
WholeLine = Left(WholeLine, Len(WholeLine) - Len(Sep))
Print #FNum, WholeLine
Next RowNdx

EndMacro:
On Error GoTo 0
Close #FNum

End Sub
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' END ExportTextFile
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''



''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
' DoTheExport
' This prompts the user for the FileName and the separtor
' character and then calls the ExportToTextFile procedure.
''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
Sub DoTheExport()
    Dim FileName As Variant
    Dim Sep As String
    Dim FileExtStr As String
    Dim FileFormatNum As Long
    Dim Sourcewb As Workbook
    Dim Destwb As Workbook
    Dim sh As Worksheet
    Dim DateString As String
    Dim FolderName As String
    Dim fldr As FileDialog
Dim sItem As String

    Set Sourcewb = ActiveWorkbook
    
        Set fldr = Application.FileDialog(msoFileDialogFolderPicker)
        With fldr
            .Title = "Select a Folder"
            .AllowMultiSelect = False
            '.InitialFileName = strPath
            If .Show <> -1 Then GoTo NextCode
            sItem = .SelectedItems(1)
        End With
NextCode:
        GetFolder = sItem
        FolderName = GetFolder

'if the file location is fixed update the path below and uncomment
'DateString = Format(Now, "yyyy-mm-dd hh-mm") 'Create new folder to save the new files in
'    FolderName = "D:\Akashmapped\" & " " & DateString
'    MkDir FolderName
    Sep = Application.InputBox("Enter a separator character.", Type:=2) ' inbox for separator input
'    If Sep = vbNullString Then ' user cancelled, get out
'    Exit Sub
FileExtStr = ".csv"
FileFormatNum = 6
        With Application
            .ScreenUpdating = False
            .EnableEvents = False
            .Calculation = xlCalculationManual
        End With
        
        For Each sh In Sourcewb.Worksheets
            sh.Activate
            sheetnamesrc = sh.Name
          '  MsgBox sheetnamesrc
            If sh.Visible = -1 Then
                sh.Copy
                  Set Destwb = ActiveWorkbook
                
                With Destwb
                    If Destwb.Sheets(1).ProtectContents = False Then
                        With Destwb.Sheets(1).UsedRange
                            .Cells.Copy
                            .Cells.PasteSpecial xlPasteValues
                            .Cells(1).Select

                        End With
                    End If
                    End With
                    With Destwb
                        .SaveAs FolderName _
                        & "\" & sheetnamesrc & FileExtStr, _
                        FileFormat:=FileFormatNum
                        .Close False
                    End With
                    FileName = FolderName & "\" & sheetnamesrc & FileExtStr
'                    If FileName = False Then
'                        ''''''''''''''''''''''''''
'                        ' user cancelled, get out
'                        ''''''''''''''''''''''''''
'                        Exit Sub
'                    End If
                    
            
                Debug.Print "FileName: " & FileName, "Separator: " & Sep
                ExportToTextFile FName:=CStr(FileName), Sep:=CStr(Sep), _
                SelectionOnly:=False, AppendData:=False
                End If
GoToNextSheet:
                Next sh
                
                MsgBox "You can find the files in " & FolderName
                
                With Application
                    .ScreenUpdating = True
                    .EnableEvents = True
                    .Calculation = xlCalculationAutomatic
                End With
           'End If
      

End Sub





 

Sub TEST_CreateTOC1()

    Call CreateTOC(False, False)

End Sub

 

Sub TEST_CreateTOC2()

    Call CreateTOC(True, True)

End Sub

 

Sub TEST_CreateTOC3()

    Call CreateTOC(False, True)

End Sub

 

Sub TEST_CreateTOC4()

    Call CreateTOC(True, False)

End Sub

 

Sub CreateTOC(Optional ByVal IncludeHiddenSheets As Boolean = False, Optional ByVal AddHomeLinkOnSheets As Boolean = False)

     '

     ' IncludeHiddenSheets

     '   Boolean

     '   Specifies whether or not hidden sheets should be included in the Table of Contents

     '

     ' AddHomeLinkOnSheets

    '   Boolean

    '   Specifies whether or not a link should be placed in each sheet linking back to the

     '   Table of Contents. This will only be placed on worksheets (i.e. not chart sheets),

     '   will not work with a protected sheet, and will overwrite anything in the cell

     '   specified in the destination [address] constant below (under declared variables).

     '

   'Use cases:

     'Call CreateTOC(False, False)

     '   This will create a Table of Contents which excludes hidden sheets and does not add a link

'   back to itself

    '

     'Call CreateTOC(True, True)

     '   This will create a Table of Contents which includes hidden sheets and also includes a link

     '   back to itself.

     '*** CAUTION: Specifying a cell in each sheet will 1) only work on worksheets (i.e. not chart sheets),

     '               overwrite anything in the destination cell (unless worksheet is protected)

     '

     'Call CreateTOC(False, True)

     '   This will create a Table of Contents which excludes hidden sheets and also includes a link

     '   back to itself.

     '*** CAUTION: Specifying a cell in each sheet will 1) only work on worksheets (i.e. not chart sheets),

     '               overwrite anything in the destination cell (unless worksheet is protected)

     '

    'Call CreateTOC(True, False)

     '   This will create a Table of Contents which includes hidden sheets and does not add a link

     '   back to itself

     '

     'Declare all variables

  Dim TOCBook As Workbook

    Dim CheckSheet As Worksheet

   Dim TOC As Worksheet

    Dim ChartButton As Shape

    Dim NewRow As Long

    Dim SheetCount As Long

    Dim CellLeft

    Dim CellTop

    Dim CellHeight

    Dim CellWidth

    Dim SheetName As String

    Dim Prompt As String

   Dim CellR1C1Address As String

    

     'Set a constant to the name of the Table of Contents

    Const TOCName As String = "TOC"

    Const HomeCell As String = "A1"

    Const StartRow As Long = 5

    

     'Check if a workbook is open or not.  If no workbook is open, quit.

    If ActiveWorkbook Is Nothing Then

        MsgBox "You must have a workbook open first!", vbInformation, "No Open Book"

        Exit Sub

    End If

    Set TOCBook = ActiveWorkbook

    

    On Error Resume Next

    Set TOC = TOCBook.Worksheets("TOC")

    On Error GoTo 0

    If Not TOC Is Nothing Then

        If MsgBox("Table of contents already exists. Overwrite?", vbYesNo + vbDefaultButton2, "Overwrite TOC?") <> vbYes Then Exit Sub

        Application.DisplayAlerts = False

        TOC.Delete

        Set TOC = Nothing

    End If

    Set TOC = TOCBook.Worksheets.Add(Before:=TOCBook.Sheets(1))

    TOC.Name = TOCName

    TOC.Columns(1).ColumnWidth = 1

    

    TOC.Cells(StartRow - 3, "B").Value = "TABLE OF CONTENTS"

    If IncludeHiddenSheets Then

        TOC.Cells(StartRow - 2, "B").Value = "Hidden sheets are italicized"

        TOC.Cells(StartRow - 2, "B").Font.Size = 10

        NewRow = StartRow

    Else

        NewRow = StartRow - 1

    End If

    

    For SheetCount = 1 To TOCBook.Sheets.Count

        SheetName = TOCBook.Sheets(SheetCount).Name

        If TOCBook.Sheets(SheetName).Name = TOCName Then GoTo SkipSheet

        If Not IncludeHiddenSheets And TOCBook.Sheets(SheetName).Visible <> xlSheetVisible Then GoTo SkipSheet

        If IsChart(SheetName) Then

             '** Sheet IS a Chart Sheet

             'Set variables for button dimensions.

            CellLeft = TOC.Range("B" & NewRow).Left

            CellTop = TOC.Range("B" & NewRow).Top

            CellWidth = TOC.Range("B" & NewRow).Width

            CellHeight = TOC.Range("B" & NewRow).RowHeight

            CellR1C1Address = "R" & NewRow & "C3"

             'Add button to cell dimensions.

            Set ChartButton = TOC.Shapes.AddShape(msoShapeRoundedRectangle, CellLeft, CellTop, CellWidth, CellHeight)

            ChartButton.Select

             'Use older technique to add Chart sheet name to button text.

            ExecuteExcel4Macro "FORMULA(""=" & CellR1C1Address & """)"

             'Format shape to look like hyperlink and match background color (transparent).

            Selection.ShapeRange.Fill.ForeColor.SchemeColor = 0

            Selection.Font.Underline = xlUnderlineStyleSingle

            Selection.Font.ColorIndex = 0

            Selection.ShapeRange.Fill.Visible = msoFalse

            Selection.ShapeRange.Line.Visible = msoFalse

        Selection.OnAction = "GotoChart"

            Selection.Name = SheetName

        Else

             '** Sheet is NOT a Chart sheet. Add a hyperlink to A1 of each sheet.

            TOC.Range("B" & NewRow).Hyperlinks.Add Anchor:=TOC.Range("B" & NewRow), Address:="#'" & SheetName & "'!A1", TextToDisplay:=SheetName

            If AddHomeLinkOnSheets Then

                If TOCBook.Sheets(SheetName).Type = xlWorksheet Then

                    If TOCBook.Sheets(SheetName).ProtectContents = False Then

                        TOCBook.Sheets(SheetName).Range(HomeCell).Value = "TOC"

                        TOCBook.Sheets(SheetName).Range(HomeCell).Hyperlinks.Add Anchor:=TOCBook.Sheets(SheetName).Range("A1"), Address:="#'" & TOCName & "'!A1", TextToDisplay:=TOCName

                    End If

                End If

            End If

        End If

         'Add name and format sheet name on TOC

        TOC.Range("B" & NewRow).Value = SheetName

        TOC.Range("B" & NewRow).HorizontalAlignment = xlLeft

        TOC.Range("B" & NewRow).Font.Italic = CBool(TOCBook.Sheets(SheetName).Visible <> xlSheetVisible)

        TOC.Range("B" & NewRow).Font.ColorIndex = 5

         'Increment row

        NewRow = NewRow + 1

SkipSheet:

    Next SheetCount

    

    TOC.Activate

    TOC.Cells(1, 1).Select

    

End Sub

 

Public Function IsChart(cName As String, Optional ChartBook As Workbook) As Boolean

    

     'Will return True or False if sheet is a Chart sheet object or not.

     'Can be used as a worksheet function.

    Dim tmpChart As Chart

    If ChartBook Is Nothing Then

        If ActiveWorkbook Is Nothing Then Exit Function

        Set ChartBook = ActiveWorkbook

    End If

   

     'Function will be determined if the object is not errored

    On Error Resume Next

    IsChart = IIf(ChartBook.Charts(cName) Is Nothing, False, True)

    On Error GoTo 0

    

End Function

 

Sub GotoChart(Optional Placebo As String = "")

    

     'This routine is to be assigned to button Object for Chart sheets only

     'as Chart sheets don't have cell references to hyperlink to.

    

    On Error Resume Next

    ActiveWorkbook.Charts(Application.Caller).Activate

    On Error GoTo 0

    If Err.number <> 0 Then Exit Sub

    

     'Optional: zoom Chart sheet to fit screen.

     'Depending on screen resolution, this may need adjustment(s).

    ActiveWindow.Zoom = 80

    

End Sub


Sub Copytoanother()
   Dim src1 As Workbook, dest2 As Workbook
   Dim sh As Worksheet
Dim entr As Integer
Dim bFileSaveAs As Boolean
Dim fNameAndPath As Variant
Dim i As Integer
entr = InputBox("Please enter 1 for current file or 2 for selecting another file as source file")
Select Case entr
Case 2
fNameAndPath = Application.GetOpenFilename(FileFilter:="Excel Files (*.XLSx), *.XLS", Title:="Select Source File To Be Opened")
If fNameAndPath = False Then Exit Sub
Workbooks.Open FileName:=fNameAndPath
GoTo Code4Macro:

Case 1

Code4Macro:
   Set src1 = ActiveWorkbook
i = 0
   Set dest2 = Workbooks.Add
  For Each sh In src1.Sheets
   i = 1 + i
      sh.Copy after:=dest2.Sheets(i)
   Next sh

dest2.Activate
    bFileSaveAs = Application.Dialogs(xlDialogSaveAs).Show
    If Not bFileSaveAs Then MsgBox "User cancelled", vbCritical
    
    dest2.Worksheets("Sheet1").Visible = False
    
    End Select
    
End Sub



Public Function ClarkeyCat(ByRef rng As Range) As Variant

Dim c As Range
Dim ans As Variant

For Each c In rng

If (c.Value <> "") Then
    ans = IIf(ans = "", "##", ans & "##") & c.Value
End If

Next

ClarkeyCat = ans
End Function




Sub ImportWorksheets()
   '=============================================
   'Process all Excel files in specified folder
   '=============================================
   Dim sFile As String           'file to process
   Dim wsTarget As Workbook
   Dim wbSource As Workbook
   Dim wsSource As Worksheet
   Dim FOLDER_PATH As String
Dim folder As String, pfile As String, ext As String

Set wsTarget = ActiveWorkbook
   'rowTarget = 2
  ' Folderpath
FOLDER_PATH = Folderpath
   'check the folder exists
   If Not FileFolderExists(FOLDER_PATH) Then
      MsgBox "Specified folder does not exist, exiting!"
      Exit Sub
   End If
   
   'reset application settings in event of error
   On Error GoTo errHandler
   Application.ScreenUpdating = False
   
   'set up the target worksheet
   'Set wsTarget = Sheets("Sheet2")
   
   'loop through the Excel files in the folder
'   sFile = Dir(FOLDER_PATH & "*.xl*")
    

sFile = Dir(FOLDER_PATH & "*.*")
Do While CBool(Len(sFile))
    ext = Chr(32) & LCase(Trim(Right(Replace(sFile, Chr(46), Space(99)), 99))) & Chr(32)
    If CBool(InStr(1, " xls xlsx csv ", ext, vbTextCompare)) Then
        'do something with the matching file
        
        Set wbSource = Workbooks.Open(FOLDER_PATH & sFile)
i = 0
 
  For Each sh In wbSource.Sheets
   i = 1 + i
      sh.Copy after:=wsTarget.Sheets(i)
    Next
      'close the source workbook, increment the output row and get the next file
      wbSource.Close SaveChanges:=False
      
 
        
        
    End If
    sFile = Dir
Loop
  
   
   
errHandler:
   On Error Resume Next
   Application.ScreenUpdating = True
   
   'tidy up
   Set wsSource = Nothing
   Set wbSource = Nothing
   Set wsTarget = Nothing
End Sub




Private Function FileFolderExists(strPath As String) As Boolean
    If Not Dir(strPath, vbDirectory) = vbNullString Then FileFolderExists = True
End Function


Public Function Folderpath() As String
   
   Dim FolderName As String
    Dim fldr As FileDialog
    
    Set fldr = Application.FileDialog(msoFileDialogFolderPicker)
        With fldr
            .Title = "Select a Folder"
            .AllowMultiSelect = False
            '.InitialFileName = strPath
            If .Show <> -1 Then GoTo NextCode
            sItem = .SelectedItems(1)
        End With
NextCode:
        GetFolder = sItem & "\"
        Folderpath = GetFolder
        
End Function

Sub ClearExcessRowsAndColumns()
    Dim ar As Range, r As Long, c As Long, tr As Long, tc As Long, x As Range
    Dim wksWks As Worksheet, ur As Range, arCount As Integer, i As Integer
    Dim blProtCont As Boolean, blProtScen As Boolean, blProtDO As Boolean
    Dim shp As Shape

    If ActiveWorkbook Is Nothing Then Exit Sub

    On Error Resume Next
    For Each wksWks In ActiveWorkbook.Worksheets
        Err.Clear
        Set ur = Nothing
        'Store worksheet protection settings and unprotect if protected.
        blProtCont = wksWks.ProtectContents
        blProtDO = wksWks.ProtectDrawingObjects
        blProtScen = wksWks.ProtectScenarios
        wksWks.Unprotect ""
        If Err.number = 1004 Then
            Err.Clear
            MsgBox "'" & wksWks.Name & _
                   "' is protected with a password and cannot be checked." _
                 , vbInformation
        Else
            Application.StatusBar = "Checking " & wksWks.Name & _
                                    ", Please Wait..."
            r = 0
            c = 0

            'Determine if the sheet contains both formulas and constants
            Set ur = Union(wksWks.UsedRange.SpecialCells(xlCellTypeConstants), _
                           wksWks.UsedRange.SpecialCells(xlCellTypeFormulas))
            'If both fails, try constants only
            If Err.number = 1004 Then
                Err.Clear
                Set ur = wksWks.UsedRange.SpecialCells(xlCellTypeConstants)
            End If
            'If constants fails then set it to formulas
            If Err.number = 1004 Then
                Err.Clear
                Set ur = wksWks.UsedRange.SpecialCells(xlCellTypeFormulas)
            End If
            'If there is still an error then the worksheet is empty
            If Err.number <> 0 Then
                Err.Clear
                If wksWks.UsedRange.Address <> "$A$1" Then
                    wksWks.UsedRange.EntireRow.Hidden = False
                    wksWks.UsedRange.EntireColumn.Hidden = False
                    wksWks.UsedRange.EntireRow.RowHeight = _
                    IIf(wksWks.StandardHeight <> 12.75, 12.75, 13)
                    wksWks.UsedRange.EntireColumn.ColumnWidth = 10
                    wksWks.UsedRange.EntireRow.Clear
                    'Reset column width which can also _
                     cause the lastcell to be innacurate
                    wksWks.UsedRange.EntireColumn.ColumnWidth = _
                    wksWks.StandardWidth
                    'Reset row height which can also cause the _
                     lastcell to be innacurate
                    If wksWks.StandardHeight < 1 Then
                        wksWks.UsedRange.EntireRow.RowHeight = 12.75
                    Else
                        wksWks.UsedRange.EntireRow.RowHeight = _
                        wksWks.StandardHeight
                    End If
                Else
                    Set ur = Nothing
                End If
            End If
            'On Error GoTo 0
            If Not ur Is Nothing Then
                arCount = ur.Areas.Count
                'determine the last column and row that contains data or formula
                For Each ar In ur.Areas
                    i = i + 1
                    tr = ar.Range("A1").Row + ar.Rows.Count - 1
                    tc = ar.Range("A1").Column + ar.Columns.Count - 1
                    If tc > c Then c = tc
                    If tr > r Then r = tr
                Next
                'Determine the area covered by shapes
                'so we don't remove shading behind shapes
                For Each shp In wksWks.Shapes
                    tr = shp.BottomRightCell.Row
                    tc = shp.BottomRightCell.Column
                    If tc > c Then c = tc
                    If tr > r Then r = tr
                Next
                Application.StatusBar = "Clearing Excess Cells in " & _
                                        wksWks.Name & ", Please Wait..."
                If r < wksWks.Rows.Count And r < wksWks.Cells.SpecialCells(xlCellTypeLastCell).Row Then
                    Set ur = wksWks.Rows(r + 1 & ":" & wksWks.Cells.SpecialCells(xlCellTypeLastCell).Row)
                    ur.EntireRow.Hidden = False
                    ur.EntireRow.RowHeight = IIf(wksWks.StandardHeight <> 12.75, _
                                                 12.75, 13)
                    'Reset row height which can also cause the _
                     lastcell to be innacurate
                    If wksWks.StandardHeight < 1 Then
                        ur.RowHeight = 12.75
                    Else
                        ur.RowHeight = wksWks.StandardHeight
                    End If
                    Set x = ur.Dependents
                    If Err.number = 0 Then
                        ur.Clear
                    Else
                        Err.Clear
                        ur.Delete
                    End If
                End If
                If c < wksWks.Columns.Count And c < wksWks.Cells.SpecialCells(xlCellTypeLastCell).Column Then
                    Set ur = wksWks.Range(wksWks.Cells(1, c + 1), _
                                          wksWks.Cells(1, wksWks.Cells.SpecialCells(xlCellTypeLastCell).Column)).EntireColumn
                    ur.EntireColumn.Hidden = False
                    ur.ColumnWidth = 18

                    'Reset column width which can _
                     also cause the lastcell to be innacurate
                    ur.EntireColumn.ColumnWidth = _
                    wksWks.StandardWidth

                    Set x = ur.Dependents
                    If Err.number = 0 Then
                        ur.Clear
                    Else
                        Err.Clear
                        ur.Delete
                    End If
                End If
            End If
        End If
        'Reset protection.
        wksWks.Protect "", blProtDO, blProtCont, blProtScen
        Err.Clear
    Next
    Application.StatusBar = False
    MsgBox "'" & ActiveWorkbook.Name & _
           "' has been cleared of excess formatting." & Chr(13) & _
           "You must save the file to keep the changes.", vbInformation
End Sub



Sub copyAll()

Dim Output As Workbook, Source As Workbook
Dim sh As Worksheet
Dim FileName As String
Dim firstCell

Application.ScreenUpdating = False
Set Source = ActiveWorkbook

Set Output = Workbooks.Add
Application.DisplayAlerts = False

Dim i As Integer

For Each sh In Source.Worksheets

    Dim newSheet As Worksheet

    ' select all used cells in the source sheet:
    sh.Activate
    sh.UsedRange.Select
    Application.CutCopyMode = False
    Selection.Copy

    ' create new destination sheet:
    Set newSheet = Output.Worksheets.Add(after:=Output.Worksheets(Output.Worksheets.Count))
    newSheet.Name = sh.Name

    ' make sure the destination sheet is selected with the right cell:
    newSheet.Activate
    firstCell = sh.UsedRange.Cells(1, 1).Address
    newSheet.Range(firstCell).Select

    ' paste the values:
    
    Range(firstCell).PasteSpecial Paste:=xlPasteValues, _
    Operation:=xlNone, SkipBlanks:=True, Transpose:=False
Range(firstCell).PasteSpecial Paste:=xlPasteColumnWidths
Range(firstCell).PasteSpecial Paste:=xlPasteFormats

Next

' delete the sheets that were originally there
While Output.Sheets.Count > Source.Worksheets.Count
  Output.Sheets(1).Delete
Wend
FileName = ThisWorkbook.Path & "\" & "worksheet2.xlsx"
Output.SaveAs FileName
Output.Close
Application.ScreenUpdating = True

End Sub



Sub Consolidate_all_sheets()
    Dim lastRb As Long
    Dim lastRoaSample As Long
    Dim lastRoa As Long
    Dim lastRoC As Long
    Dim Array_2()
    Dim Array_1
    Dim a_sn As String
    Dim var As String
    Dim msg As String
    Dim hashedvalues() As Variant
    Dim splitvalues() As String
    Dim arrforsort As Variant
    Dim arr As New Collection, A
    Dim f As Long
    Dim deduplicated As String
    Dim checkSheetName As String
     Dim newSheetName As String
     
     
    newSheetName = Application.InputBox("Input Sheet Name:", , "sheet4", , , , , 2)
    On Error Resume Next
    checkSheetName = Worksheets(newSheetName).Name
    If checkSheetName = "" Then
        Worksheets.Add.Name = newSheetName
        MsgBox "The sheet named ''" & newSheetName & _
        "'' does not exist in this workbook but it has been created now.", _
        vbInformation, "Kutools for Excel"
         
    Else
        MsgBox "The sheet named ''" & newSheetName & _
        "''exist in this workbook.", vbInformation, "Kutools for Excel"
    End If
    
    
    For i = 1 To Worksheets.Count
        If Sheets(i).Name <> "Sample" Then
            Sheets(i).Activate
            With ActiveSheet
                lastRoa = .Cells(.Rows.Count, "A").End(xlUp).Row
            End With
            With ActiveSheet
                lastRoC = .Cells(.Rows.Count, "C").End(xlUp).Row
            End With
            
            
            If (lastRoC > lastRoa) Or (lastRoC = lastRoa) Then
            Columns("A:A").Select
            Selection.Insert Shift:=xlToRight, CopyOrigin:=xlFormatFromLeftOrAbove
            Range("A1:A" & lastRoC).Value = Sheets(i).Name
            
            With ActiveSheet
                    lastRoaSample = .Cells(.Rows.Count, "A").End(xlUp).Row
                End With
                Sheets(i).Activate
                Range("A1:Z" & lastRoC).Copy
                Worksheets(newSheetName).Activate
                With Cells(lastRoaSample + 1, 1)
                    .PasteSpecial xlPasteValues
                    .PasteSpecial xlPasteFormats
                    Application.CutCopyMode = False
                End With
                
         
            
        Else
        Columns("A:A").Select
            Selection.Insert Shift:=xlToRight, CopyOrigin:=xlFormatFromLeftOrAbove
            Range("A1:A" & lastRoa).Value = Sheets(i).Name
            Worksheets(newSheetName).Activate
            With ActiveSheet
                lastRoaSample = .Cells(.Rows.Count, "A").End(xlUp).Row
            End With
            Sheets(i).Activate
            Range("A1:Z" & lastRoa).Copy
            Worksheets(newSheetName).Activate
            With Cells(lastRoaSample + 1, 1)
                .PasteSpecial xlPasteValues
                .PasteSpecial xlPasteFormats
                Application.CutCopyMode = False
            End With
            
            
               End If
            
        End If
        
    Next
    
End Sub



    

Sub TestSheetCreate()
'Updateby Extendoffice 20160922
    Dim newSheetName As String
    Dim checkSheetName As String
    newSheetName = Application.InputBox("Input Sheet Name:", "Kutools for Excel", _
                                    "sheet4", , , , , 2)
    On Error Resume Next
    checkSheetName = Worksheets(newSheetName).Name
    If checkSheetName = "" Then
        Worksheets.Add.Name = newSheetName
        MsgBox "The sheet named ''" & newSheetName & _
        "'' does not exist in this workbook but it has been created now.", _
        vbInformation, "Kutools for Excel"
         
    Else
        MsgBox "The sheet named ''" & newSheetName & _
        "''exist in this workbook.", vbInformation, "Kutools for Excel"
    End If
End Sub


